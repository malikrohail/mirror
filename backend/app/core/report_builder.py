"""Report builder — generates Markdown and PDF reports from study results."""

from __future__ import annotations

import io
import logging
from datetime import datetime, timezone
from typing import Any

from app.llm.client import LLMClient
from app.llm.schemas import ReportContent, StudySynthesis

logger = logging.getLogger(__name__)


class ReportBuilder:
    """Generates professional usability test reports in Markdown and PDF."""

    def __init__(self, llm_client: LLMClient) -> None:
        self._llm = llm_client

    async def generate_report_content(
        self,
        study_url: str,
        synthesis: StudySynthesis,
        session_summaries: list[dict[str, Any]],
        tasks: list[str],
    ) -> ReportContent:
        """Generate structured report content via LLM."""
        logger.info("Generating report content for %s", study_url)
        return await self._llm.generate_report(
            study_url=study_url,
            synthesis=synthesis.model_dump(),
            session_summaries=session_summaries,
            tasks=tasks,
        )

    def render_markdown(
        self,
        report: ReportContent,
        synthesis: StudySynthesis,
        session_summaries: list[dict[str, Any]],
    ) -> str:
        """Render report content to a Markdown string."""
        lines: list[str] = []

        # Title
        lines.append(f"# {report.title}")
        lines.append("")
        lines.append(f"*Generated on {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}*")
        lines.append("")

        # Score badge
        score = synthesis.overall_ux_score
        grade = _score_to_grade(score)
        lines.append(f"**Overall UX Score: {score}/100 ({grade})**")
        lines.append("")

        # Executive summary
        lines.append("## Executive Summary")
        lines.append("")
        lines.append(report.executive_summary)
        lines.append("")

        # Methodology
        lines.append("## Methodology")
        lines.append("")
        lines.append(report.methodology)
        lines.append("")

        # Persona overview table
        lines.append("## Persona Overview")
        lines.append("")
        lines.append("| Persona | Completed | Steps | Difficulty |")
        lines.append("|---------|-----------|-------|-----------|")
        for s in session_summaries:
            name = s.get("persona_name", "Unknown")
            completed = "Yes" if s.get("task_completed") else "No"
            steps = s.get("total_steps", "?")
            difficulty = s.get("overall_difficulty", "?")
            lines.append(f"| {name} | {completed} | {steps} | {difficulty} |")
        lines.append("")

        # Report sections from LLM
        for section in report.sections:
            lines.append(f"## {section.heading}")
            lines.append("")
            lines.append(section.content)
            lines.append("")
            for sub in section.subsections:
                lines.append(f"### {sub.heading}")
                lines.append("")
                lines.append(sub.content)
                lines.append("")

        # Recommendations summary
        if synthesis.recommendations:
            lines.append("## Prioritized Recommendations")
            lines.append("")
            lines.append("| # | Recommendation | Impact | Effort |")
            lines.append("|---|---------------|--------|--------|")
            for rec in synthesis.recommendations:
                lines.append(
                    f"| {rec.rank} | {rec.title} | {rec.impact} | {rec.effort} |"
                )
            lines.append("")

        # Conclusion
        lines.append("## Conclusion")
        lines.append("")
        lines.append(report.conclusion)
        lines.append("")
        lines.append("---")
        lines.append("*Report generated by Mirror — AI Usability Testing Platform*")

        return "\n".join(lines)

    def render_pdf(
        self,
        markdown_content: str,
        study_url: str,
    ) -> bytes:
        """Convert Markdown report to PDF using WeasyPrint.

        Returns PDF as bytes. Falls back to a plaintext PDF if WeasyPrint
        is not available.
        """
        html = self._markdown_to_html(markdown_content, study_url)

        try:
            from weasyprint import HTML as WeasyHTML
            pdf_bytes = WeasyHTML(string=html).write_pdf()
            logger.info("PDF report generated (%d bytes)", len(pdf_bytes))
            return pdf_bytes
        except ImportError:
            logger.warning("WeasyPrint not installed, returning HTML as PDF fallback")
            return html.encode("utf-8")

    @staticmethod
    def _markdown_to_html(md_content: str, study_url: str) -> str:
        """Convert Markdown to styled HTML for PDF rendering."""
        # Simple Markdown → HTML conversion for common elements
        import re

        html_lines: list[str] = []

        for line in md_content.split("\n"):
            # Headers
            if line.startswith("# "):
                html_lines.append(f"<h1>{line[2:]}</h1>")
            elif line.startswith("## "):
                html_lines.append(f"<h2>{line[3:]}</h2>")
            elif line.startswith("### "):
                html_lines.append(f"<h3>{line[4:]}</h3>")
            # Table rows
            elif line.startswith("|"):
                if line.startswith("|---") or line.startswith("| ---"):
                    continue  # Skip separator rows
                cells = [c.strip() for c in line.split("|")[1:-1]]
                row = "".join(f"<td>{c}</td>" for c in cells)
                html_lines.append(f"<tr>{row}</tr>")
            # Bold / italic
            elif line.strip():
                line = re.sub(r"\*\*(.+?)\*\*", r"<strong>\1</strong>", line)
                line = re.sub(r"\*(.+?)\*", r"<em>\1</em>", line)
                html_lines.append(f"<p>{line}</p>")
            else:
                html_lines.append("")

        body = "\n".join(html_lines)

        return f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mirror UX Report — {study_url}</title>
<style>
    body {{
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 800px;
        margin: 40px auto;
        padding: 0 20px;
        color: #1a1a1a;
        line-height: 1.6;
    }}
    h1 {{ color: #111; border-bottom: 2px solid #6366f1; padding-bottom: 8px; }}
    h2 {{ color: #333; margin-top: 2em; }}
    h3 {{ color: #555; }}
    table {{ border-collapse: collapse; width: 100%; margin: 1em 0; }}
    td, th {{ border: 1px solid #ddd; padding: 8px 12px; text-align: left; }}
    tr:nth-child(even) {{ background: #f9f9f9; }}
    strong {{ color: #6366f1; }}
    em {{ color: #666; }}
    hr {{ border: none; border-top: 1px solid #eee; margin: 2em 0; }}
</style>
</head>
<body>
{body}
</body>
</html>"""


def _score_to_grade(score: int) -> str:
    if score >= 90:
        return "Excellent"
    elif score >= 70:
        return "Good"
    elif score >= 50:
        return "Fair"
    elif score >= 30:
        return "Poor"
    else:
        return "Critical"
