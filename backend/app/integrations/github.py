"""GitHub integration â€” export Mirror UX issues as GitHub issues."""

from __future__ import annotations

import logging
from typing import Any

import httpx

logger = logging.getLogger(__name__)

GITHUB_API_BASE = "https://api.github.com"


class GitHubIntegration:
    """Exports Mirror UX issues to GitHub as well-structured issues.

    Creates GitHub issues from Mirror's issue data, formatting them with
    severity badges, affected elements, heuristic violations, WCAG criteria,
    recommendations, and fix code suggestions.
    """

    def __init__(self) -> None:
        self._http_client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        """Get or create the shared HTTP client."""
        if self._http_client is None or self._http_client.is_closed:
            self._http_client = httpx.AsyncClient(
                base_url=GITHUB_API_BASE,
                timeout=30.0,
            )
        return self._http_client

    async def close(self) -> None:
        """Close the HTTP client."""
        if self._http_client and not self._http_client.is_closed:
            await self._http_client.aclose()

    @staticmethod
    def _severity_label(severity: str) -> str:
        """Map Mirror severity to a GitHub-friendly label."""
        labels = {
            "critical": "priority: critical",
            "major": "priority: high",
            "minor": "priority: medium",
            "enhancement": "enhancement",
        }
        return labels.get(severity.lower(), "bug")

    @staticmethod
    def _format_issue_body(issue_data: dict[str, Any]) -> str:
        """Format a Mirror UX issue into a well-structured GitHub issue body.

        Args:
            issue_data: Dictionary containing issue fields (description,
                severity, element, heuristic, wcag_criterion, recommendation,
                page_url, fix_code, fix_language).

        Returns:
            Markdown-formatted GitHub issue body.
        """
        severity = issue_data.get("severity", "unknown")
        severity_emoji = {
            "critical": "ðŸ”´",
            "major": "ðŸŸ ",
            "minor": "ðŸŸ¡",
            "enhancement": "ðŸ”µ",
        }.get(severity.lower(), "âšª")

        sections: list[str] = []

        # Header with severity badge
        sections.append(
            f"## {severity_emoji} UX Issue â€” {severity.upper()}\n"
        )

        # Description
        description = issue_data.get("description", "No description provided.")
        sections.append(f"**Description:** {description}\n")

        # Details table
        details: list[str] = ["| Field | Value |", "|-------|-------|"]

        element = issue_data.get("element")
        if element:
            details.append(f"| **Element** | `{element}` |")

        page_url = issue_data.get("page_url")
        if page_url:
            details.append(f"| **Page URL** | {page_url} |")

        heuristic = issue_data.get("heuristic")
        if heuristic:
            details.append(f"| **Heuristic Violated** | {heuristic} |")

        wcag = issue_data.get("wcag_criterion")
        if wcag:
            details.append(f"| **WCAG Criterion** | {wcag} |")

        details.append(f"| **Severity** | {severity_emoji} {severity} |")

        if len(details) > 2:
            sections.append("\n".join(details) + "\n")

        # Recommendation
        recommendation = issue_data.get("recommendation")
        if recommendation:
            sections.append(f"### Recommendation\n\n{recommendation}\n")

        # Fix code
        fix_code = issue_data.get("fix_code")
        if fix_code:
            fix_language = issue_data.get("fix_language", "")
            sections.append(
                f"### Suggested Fix\n\n```{fix_language}\n{fix_code}\n```\n"
            )

        # Footer
        sections.append(
            "---\n*Generated by [Mirror](https://github.com/mirror-ai) â€” "
            "AI-powered usability testing*"
        )

        return "\n".join(sections)

    async def create_issue(
        self,
        repo: str,
        token: str,
        issue_data: dict[str, Any],
    ) -> str:
        """Create a single GitHub issue from a Mirror UX issue.

        Args:
            repo: GitHub repository in "owner/repo" format.
            token: GitHub personal access token with repo scope.
            issue_data: Mirror issue data containing description, severity,
                element, heuristic, wcag_criterion, recommendation, etc.

        Returns:
            The URL of the created GitHub issue.

        Raises:
            httpx.HTTPStatusError: If the GitHub API returns an error.
        """
        client = await self._get_client()

        # Build title from severity and description
        severity = issue_data.get("severity", "unknown")
        description = issue_data.get("description", "UX issue")
        title = f"[Mirror/{severity.upper()}] {description[:80]}"

        body = self._format_issue_body(issue_data)

        labels = ["mirror-ux", self._severity_label(severity)]
        wcag = issue_data.get("wcag_criterion")
        if wcag:
            labels.append("accessibility")

        payload = {
            "title": title,
            "body": body,
            "labels": labels,
        }

        logger.info("Creating GitHub issue in %s: %s", repo, title[:60])

        response = await client.post(
            f"/repos/{repo}/issues",
            json=payload,
            headers={
                "Authorization": f"Bearer {token}",
                "Accept": "application/vnd.github+json",
                "X-GitHub-Api-Version": "2022-11-28",
            },
        )
        response.raise_for_status()

        issue_url = response.json()["html_url"]
        logger.info("GitHub issue created: %s", issue_url)
        return issue_url

    async def bulk_export(
        self,
        repo: str,
        token: str,
        issues: list[dict[str, Any]],
    ) -> list[str]:
        """Export multiple Mirror UX issues to GitHub.

        Args:
            repo: GitHub repository in "owner/repo" format.
            token: GitHub personal access token with repo scope.
            issues: List of Mirror issue data dictionaries.

        Returns:
            List of created GitHub issue URLs. Failed issues are skipped
            and logged as warnings.
        """
        logger.info("Bulk exporting %d issues to %s", len(issues), repo)

        created_urls: list[str] = []
        for i, issue_data in enumerate(issues):
            try:
                url = await self.create_issue(
                    repo=repo,
                    token=token,
                    issue_data=issue_data,
                )
                created_urls.append(url)
            except httpx.HTTPStatusError as e:
                logger.warning(
                    "Failed to create GitHub issue %d/%d: %s %s",
                    i + 1,
                    len(issues),
                    e.response.status_code,
                    e.response.text[:200],
                )
            except Exception as e:
                logger.warning(
                    "Failed to create GitHub issue %d/%d: %s",
                    i + 1,
                    len(issues),
                    e,
                )

        logger.info(
            "Bulk export complete: %d/%d issues created in %s",
            len(created_urls),
            len(issues),
            repo,
        )
        return created_urls
